// Code generated by tempo, DO NOT EDIT.
package dist_auth

import runtime "tempo/runtime"

// Projection of interface ClientRegistry
type ClientRegistry_A interface {
	GetSalt(env *runtime.Env, username int) int
	Check(env *runtime.Env, hash int) bool
}

// Projection of interface TokenGenerator
type TokenGenerator_A interface {
	GenerateToken(env *runtime.Env) int
}

// Projection of struct Credentials
type Credentials_A struct {
	Username int `json:"Username"`
	Password int `json:"Password"`
}

// Projection of struct AuthResult
type AuthResult_C struct {
	Success bool `json:"Success"`
	Token   int  `json:"Token"`
}
type AuthResult_S struct {
	Success bool `json:"Success"`
	Token   int  `json:"Token"`
}

// Projection of choreography calcHash
func calcHash_A(env *runtime.Env, salt int, password int) int {
	return password + salt
}

// Projection of choreography Authenticate
func Authenticate_Client(env *runtime.Env, credentials Credentials_A) AuthResult_C {
	env.Send(credentials.Username, "IP")
	var salt *runtime.Async = env.Recv("IP")
	_ = salt
	var tmp0 *runtime.Async = runtime.FixedAsync(calcHash_A(env.Subst("Client", "A"), salt.Get().(int), credentials.Password))
	_ = tmp0
	env.Send(tmp0.Get().(int), "IP")
	var valid *runtime.Async = env.Recv("IP")
	_ = valid
	if valid.Get().(bool) {
		var token *runtime.Async = env.Recv("IP")
		_ = token
		return AuthResult_C{
			Success: true,
			Token:   token.Get().(int),
		}
	} else {
		return AuthResult_C{
			Success: false,
			Token:   0,
		}
	}
}
func Authenticate_Service(env *runtime.Env) AuthResult_S {
	var valid *runtime.Async = env.Recv("IP")
	_ = valid
	if valid.Get().(bool) {
		var token *runtime.Async = env.Recv("IP")
		_ = token
		return AuthResult_S{
			Success: true,
			Token:   token.Get().(int),
		}
	} else {
		return AuthResult_S{
			Success: false,
			Token:   0,
		}
	}
}
func Authenticate_IP(env *runtime.Env, registry ClientRegistry_A, tokenGen TokenGenerator_A) {
	var username *runtime.Async = env.Recv("Client")
	_ = username
	var tmp1 *runtime.Async = runtime.FixedAsync(registry.GetSalt(env.Subst("IP", "A"), username.Get().(int)))
	_ = tmp1
	env.Send(tmp1.Get().(int), "Client")
	var hash *runtime.Async = env.Recv("Client")
	_ = hash
	var tmp2 *runtime.Async = runtime.FixedAsync(registry.Check(env.Subst("IP", "A"), hash.Get().(int)))
	_ = tmp2
	env.Send(tmp2.Get().(bool), "Client", "Service")
	var valid *runtime.Async = tmp2
	_ = valid
	if valid.Get().(bool) {
		var tmp3 *runtime.Async = runtime.FixedAsync(tokenGen.GenerateToken(env.Subst("IP", "A")))
		_ = tmp3
		env.Send(tmp3.Get().(int), "Client", "Service")
	}
}
