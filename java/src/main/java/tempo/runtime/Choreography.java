// Code generated by tempo, DO NOT EDIT.
package tempo.runtime;

import java.util.concurrent.Future;
import tempo.runtime.Env;
import tempo.runtime.function.FnRet1;

public final class Choreography {
  private Choreography() {}
  // Projection of interface `RPC`
  public interface RPC_A {
    public Future<Integer> call(Env env, Integer input) throws Exception;
  }
  public interface RPC_B {
    public void call(Env env) throws Exception;
  }
  
  // Projection of struct `RemoteCall`
  public static final class RemoteCall_A implements Cloneable, RPC_A {
    public RemoteCall_A() {
    }
    
    public Future<Integer> call(Env env, Integer input) throws Exception {
      env.send(input, "B").get();
      return env.<Integer>recv("B");
    }
    
    public RemoteCall_A clone() {
      return new RemoteCall_A();
    }
  }
  public static final class RemoteCall_B implements Cloneable, RPC_B {
    public FnRet1<Integer, Integer> fn;
    
    public RemoteCall_B(FnRet1<Integer, Integer> fn) {
      this.fn = fn;
    }
    
    public void call(Env env) throws Exception {
      Integer output = this.fn.call(env.<Integer>recv("A").get());
      env.send(output, "A");
    }
    
    public RemoteCall_B clone() {
      return new RemoteCall_B(fn);
    }
  }
  
  // Projection of choreography `main`
  public static void main_A(Env env) throws Exception {
    RPC_A rpc = new RemoteCall_A();
    Integer result = rpc.call(env, 10).get();
  }
  public static void main_B(Env env) throws Exception {
    FnRet1<Integer, Integer> dbl = (input) -> {
      return input * 2;
    };
    RPC_B rpc = new RemoteCall_B(dbl);
    rpc.call(env);
  }
}
