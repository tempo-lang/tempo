// Code generated by tempo, DO NOT EDIT.
package compose_closures;

import tempo.runtime.Env;
import tempo.runtime.function.Fn0;
import tempo.runtime.function.Fn1;
import tempo.runtime.function.FnRet0;

public final class Choreography {
  private Choreography() {}
  
  // Projection of choreography `compose`
  public static Fn1<Integer> compose_A(Env env, Fn1<Integer> f) throws Exception {
    return (input) -> {
      f.call(input);
    };
  }
  public static Fn0 compose_B(Env env, FnRet0<Integer> f, Fn1<Integer> g) throws Exception {
    return () -> {
      g.call(f.call());
    };
  }
  public static FnRet0<Integer> compose_C(Env env, FnRet0<Integer> g) throws Exception {
    return () -> {
      return g.call();
    };
  }
  
  // Projection of choreography `incAndSend`
  public static void incAndSend_X(Env env, Integer value) throws Exception {
    env.send(value + 1, "Y").get();
  }
  public static Integer incAndSend_Y(Env env) throws Exception {
    return env.<Integer>recv("X").get();
  }
  
  // Projection of choreography `Start`
  public static void Start_A(Env env, Integer input) throws Exception {
    Fn1<Integer> f = (value) -> {
      incAndSend_X(env.subst("A", "X", "B", "Y"), value);
    };
    Fn1<Integer> c = compose_A(env, f);
    c.call(input);
  }
  public static void Start_B(Env env) throws Exception {
    FnRet0<Integer> f = () -> {
      return incAndSend_Y(env.subst("A", "X", "B", "Y"));
    };
    Fn1<Integer> g = (value) -> {
      incAndSend_X(env.subst("B", "X", "C", "Y"), value);
    };
    Fn0 c = compose_B(env, f, g);
    c.call();
  }
  public static Integer Start_C(Env env) throws Exception {
    FnRet0<Integer> g = () -> {
      return incAndSend_Y(env.subst("B", "X", "C", "Y"));
    };
    FnRet0<Integer> c = compose_C(env, g);
    return c.call();
  }
}
