// Code generated by tempo, DO NOT EDIT.
package dist_auth;

import java.util.Objects;
import java.util.concurrent.Future;
import tempo.runtime.Env;

public final class Choreography {
  private Choreography() {}
  // Projection of interface `ClientRegistry`
  public interface ClientRegistry_A {
    public String GetSalt(Env env, String username) throws Exception;
    public Boolean Check(Env env, String hash) throws Exception;
  }
  
  // Projection of interface `TokenGenerator`
  public interface TokenGenerator_A {
    public String GenerateToken(Env env) throws Exception;
  }
  
  // Projection of interface `Hasher`
  public interface Hasher_A {
    public String CalcHash(Env env, String salt, String password) throws Exception;
  }
  
  // Projection of struct `Credentials`
  public static final class Credentials_A implements Cloneable {
    public String Username;
    public String Password;
    
    public Credentials_A(String Username, String Password) {
      this.Username = Username;
      this.Password = Password;
    }
    
    @Override
    public String toString() {
      return "Credentials_A[Username="+this.Username+", Password="+this.Password+"]";
    }
    
    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      if (getClass() != o.getClass()) return false;
      Credentials_A oo = (Credentials_A) o;
      return Objects.equals(this.Username, oo.Username) && Objects.equals(this.Password, oo.Password);
    }
    
    @Override
    public Credentials_A clone() {
      return new Credentials_A(Username, Password);
    }
  }
  // Projection of struct `AuthResult`
  public static final class AuthResult_C implements Cloneable {
    public Boolean Success;
    public String Token;
    
    public AuthResult_C(Boolean Success, String Token) {
      this.Success = Success;
      this.Token = Token;
    }
    
    @Override
    public String toString() {
      return "AuthResult_C[Success="+this.Success+", Token="+this.Token+"]";
    }
    
    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      if (getClass() != o.getClass()) return false;
      AuthResult_C oo = (AuthResult_C) o;
      return Objects.equals(this.Success, oo.Success) && Objects.equals(this.Token, oo.Token);
    }
    
    @Override
    public AuthResult_C clone() {
      return new AuthResult_C(Success, Token);
    }
  }
  public static final class AuthResult_S implements Cloneable {
    public Boolean Success;
    public String Token;
    
    public AuthResult_S(Boolean Success, String Token) {
      this.Success = Success;
      this.Token = Token;
    }
    
    @Override
    public String toString() {
      return "AuthResult_S[Success="+this.Success+", Token="+this.Token+"]";
    }
    
    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      if (getClass() != o.getClass()) return false;
      AuthResult_S oo = (AuthResult_S) o;
      return Objects.equals(this.Success, oo.Success) && Objects.equals(this.Token, oo.Token);
    }
    
    @Override
    public AuthResult_S clone() {
      return new AuthResult_S(Success, Token);
    }
  }
  
  // Projection of choreography `Authenticate`
  public static AuthResult_C Authenticate_Client(Env env, Credentials_A credentials, Hasher_A hasher) throws Exception {
    env.send(credentials.Username, "IP");
    Future<String> salt = env.<String>recv("IP");
    env.send(hasher.CalcHash(env.subst("Client", "A"), salt.get(), credentials.Password), "IP");
    Future<Boolean> valid = env.<Boolean>recv("IP");
    if (valid.get()) {
      Future<String> token = env.<String>recv("IP");
      return new AuthResult_C(true, token.get());
    } else {
      return new AuthResult_C(false, "");
    }
  }
  public static AuthResult_S Authenticate_Service(Env env) throws Exception {
    Future<Boolean> valid = env.<Boolean>recv("IP");
    if (valid.get()) {
      Future<String> token = env.<String>recv("IP");
      return new AuthResult_S(true, token.get());
    } else {
      return new AuthResult_S(false, "");
    }
  }
  public static void Authenticate_IP(Env env, ClientRegistry_A registry, TokenGenerator_A tokenGen) throws Exception {
    Future<String> username = env.<String>recv("Client");
    env.send(registry.GetSalt(env.subst("IP", "A"), username.get()), "Client");
    Future<String> hash = env.<String>recv("Client");
    Future<Boolean> valid = env.send(registry.Check(env.subst("IP", "A"), hash.get()), "Client", "Service");
    if (valid.get()) {
      env.send(tokenGen.GenerateToken(env.subst("IP", "A")), "Client", "Service");
    }
  }
}
