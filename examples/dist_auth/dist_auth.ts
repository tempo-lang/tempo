// Code generated by tempo, DO NOT EDIT.

import { Env } from '../../typescript/runtime.ts';

// Projection of interface `ClientRegistry`
export interface ClientRegistry_A {
  GetSalt(env: Env, username: string): Promise<string>;
  Check(env: Env, hash: string): Promise<boolean>;
}

// Projection of interface `TokenGenerator`
export interface TokenGenerator_A {
  GenerateToken(env: Env): Promise<string>;
}

// Projection of interface `Hasher`
export interface Hasher_A {
  CalcHash(env: Env, salt: string, password: string): Promise<string>;
}

// Projection of struct `Credentials`
export interface Credentials_A_attrs {
  Username: string;
  Password: string;
}
export class Credentials_A implements Credentials_A_attrs {
  Username: string;
  Password: string;
  
  constructor({ Username, Password }: Credentials_A_attrs) {
    this.Username = Username;
    this.Password = Password;
  }
}


// Projection of struct `AuthResult`
export interface AuthResult_C_attrs {
  Success: boolean;
  Token: string;
}
export class AuthResult_C implements AuthResult_C_attrs {
  Success: boolean;
  Token: string;
  
  constructor({ Success, Token }: AuthResult_C_attrs) {
    this.Success = Success;
    this.Token = Token;
  }
}

export interface AuthResult_S_attrs {
  Success: boolean;
  Token: string;
}
export class AuthResult_S implements AuthResult_S_attrs {
  Success: boolean;
  Token: string;
  
  constructor({ Success, Token }: AuthResult_S_attrs) {
    this.Success = Success;
    this.Token = Token;
  }
}


// Projection of choreography `Authenticate`
export async function Authenticate_Client(env: Env, credentials: Credentials_A, hasher: Hasher_A): Promise<AuthResult_C> {
  env.send(credentials.Username, "IP");
  let salt: Promise<string> = env.recv<string>("IP");
  env.send(await hasher.CalcHash(env.subst("Client", "A"), await salt, credentials.Password), "IP");
  let valid: Promise<boolean> = env.recv<boolean>("IP");
  if (await valid) {
    let token: Promise<string> = env.recv<string>("IP");
    return new AuthResult_C({ Success: true, Token: await token });
  } else {
    return new AuthResult_C({ Success: false, Token: "" });
  }
}
export async function Authenticate_Service(env: Env): Promise<AuthResult_S> {
  let valid: Promise<boolean> = env.recv<boolean>("IP");
  if (await valid) {
    let token: Promise<string> = env.recv<string>("IP");
    return new AuthResult_S({ Success: true, Token: await token });
  } else {
    return new AuthResult_S({ Success: false, Token: "" });
  }
}
export async function Authenticate_IP(env: Env, registry: ClientRegistry_A, tokenGen: TokenGenerator_A) {
  let username: Promise<string> = env.recv<string>("Client");
  env.send(await registry.GetSalt(env.subst("IP", "A"), await username), "Client");
  let hash: Promise<string> = env.recv<string>("Client");
  let valid: Promise<boolean> = env.send(await registry.Check(env.subst("IP", "A"), await hash), "Client", "Service");
  if (await valid) {
    env.send(await tokenGen.GenerateToken(env.subst("IP", "A")), "Client", "Service");
  }
}

