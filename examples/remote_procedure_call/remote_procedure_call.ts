// Code generated by tempo, DO NOT EDIT.

import { Env } from '../../typescript/runtime.ts';

// Projection of interface `RPC`
export interface RPC_A {
  Call(env: Env, input: number): Promise<Promise<number>>;
}
export interface RPC_B {
  Call(env: Env): Promise<void>;
}

// Projection of struct `RemoteCall`
export interface RemoteCall_A_attrs {
}
export class RemoteCall_A implements RemoteCall_A_attrs {
  
  constructor({  }: RemoteCall_A_attrs) {
  }
  
  async Call(env: Env, input: number): Promise<Promise<number>> {
    await env.send(input, "B");
    return env.recv<number>("B");
  }
}

export interface RemoteCall_B_attrs {
  Fn: (env: Env, arg0: number) => Promise<number>;
}
export class RemoteCall_B implements RemoteCall_B_attrs {
  Fn: (env: Env, arg0: number) => Promise<number>;
  
  constructor({ Fn }: RemoteCall_B_attrs) {
    this.Fn = Fn;
  }
  
  async Call(env: Env) {
    let output: number = await this.Fn(env, await env.recv<number>("A"));
    env.send(output, "A");
  }
}


// Projection of choreography `Start`
export async function Start_A(env: Env) {
  let rpc: RPC_A = new RemoteCall_A({  });
  let result: number = await rpc.Call(env, 10);
}
export async function Start_B(env: Env) {
  let timesTwo: (env: Env, arg0: number) => Promise<number> = async (env: Env, input: number): Promise<number> => {
    return input * 2;
  };
  let rpc: RPC_B = env.copy(new RemoteCall_B({ Fn: timesTwo }));
  await rpc.Call(env);
}

