// Code generated by tempo, DO NOT EDIT.
package diffie_hellman;

import java.util.Objects;
import java.util.concurrent.Future;
import tempo.runtime.Env;

public final class Choreography {
  private Choreography() {}
  // Projection of interface `Math`
  public interface Math {
    public Integer Exp(Env env, Integer base, Integer exp) throws Exception;
  }
  
  // Projection of struct `Secret`
  public static final class Secret_A implements Cloneable {
    public Integer A;
    
    public Secret_A(Integer A) {
      this.A = A;
    }
    
    @Override
    public String toString() {
      return "Secret_A[A="+this.A+"]";
    }
    
    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      if (getClass() != o.getClass()) return false;
      Secret_A oo = (Secret_A) o;
      return Objects.equals(this.A, oo.A);
    }
    
    @Override
    public Secret_A clone() {
      return new Secret_A(A);
    }
  }
  public static final class Secret_B implements Cloneable {
    public Integer B;
    
    public Secret_B(Integer B) {
      this.B = B;
    }
    
    @Override
    public String toString() {
      return "Secret_B[B="+this.B+"]";
    }
    
    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      if (getClass() != o.getClass()) return false;
      Secret_B oo = (Secret_B) o;
      return Objects.equals(this.B, oo.B);
    }
    
    @Override
    public Secret_B clone() {
      return new Secret_B(B);
    }
  }
  
  // Projection of choreography `DiffieHellman`
  public static Secret_A DiffieHellman_A(Env env, Math mathA) throws Exception {
    Integer p = 23;
    Integer g = 5;
    Integer a = 4;
    env.send(mathA.Exp(env.subst("A", ""), g, a) % p, "B");
    Future<Integer> B = env.<Integer>recv("B");
    Integer sA = mathA.Exp(env.subst("A", ""), B.get(), a) % p;
    return new Secret_A(sA);
  }
  public static Secret_B DiffieHellman_B(Env env, Math mathB) throws Exception {
    Integer p = 23;
    Integer g = 5;
    Integer b = 3;
    Future<Integer> A = env.<Integer>recv("A");
    env.send(mathB.Exp(env.subst("B", ""), g, b) % p, "A");
    Integer sB = mathB.Exp(env.subst("B", ""), A.get(), b) % p;
    return new Secret_B(sB);
  }
}
